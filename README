Compile: make / make all
Run tests: make clean && make TEST=1
Run in qemu: make qemu / make qemu-nox
Debug with gdb: make qemu-gdb / make qemu-nox-gdb
                (in another terminal) gdb

To use your solutions from lab 1: git merge lab1
To use sample lab 1 solutions: copy files in samples/ to appropriate directories

List here the following info:
1. who you have worked with
2. whether you coded this assignment together, and if not, who worked on which part
3. brief description of what you have implemented
4. and anything else you would like us to know

0. initialize debugger & debuggee
    Spawn debugger process  <-- we can do this automatically
    Spawn user process
        - sys_debugger_spawn to initialize but not execute the user process
        - tcb_set_debugger(int user_pid, int debugger_pid) register debugger PID in the user process TCB 

1. Read a bunch of addresses to stop at in the debuggee process.
    Invalidate memory addresses provided by debugger
        - set address with no read permission
        - add a special DEBUG flag (similar to the COW flag)

2. Start the debuggee (for example with a start command).
    return control back to the debugee process

3. When a breakpoint is hit, control goes back to the debugger and the user can either type commands to dump the contents of the memory (dump 0x12345678) or resume the execution (continue).
    In TTrapHandler.c, if we get a page fault/memory error, check for the presence of the DEBUG flag
        - if DEBUG is present, find the "debugger" id of the current id, and give it control

4. Back to 3. 

5. Clean up the break points in that process


What we're able to do:
    - type in a memory address, and turn it into a breakpoint
    - have user code stop execution at that breakpoint and transfer to debugger
    - return control to user code and continue execution
    - HOWEVER: this process removes the breakpoint
        - we don't 


our approach to writing interrupts in the user code:
    - given a vaddr, find its physical address
        - do this by calling get_ptbl_entry_by_va, finding the upper 20 bits
          (physical frame address), and adding the offset from the vaddr
    - call memset to write 0xcc to the first byte of the physical addresses

for ex:
    - given 0x40000ef8
        - we translated that into physical address 0x4000fef8
        - called memset((void*) 0x4000fef8, 0xcc, 1)

however, even though 0x40000ef8 is in the user code that should be executed,
we don't see the breakpoint interrupt ever get raised

but: when we set breakpoints elsewhere in the code (like in the printf function),
we do see them raised. this makes us think that calling memset is fine (it
successfully writes "int 3" into the code), but we're just doing it at the wrong address.

for ex:
    - given 0x40000260 (the user memory address of the kernel printf function)
    - doing our above process causes a breakpoint interrupt to be raised with 
      the fault_va 0xeffffffc
